// Code generated by pgen.go. DO NOT EDIT.

package ascon

import (
	"encoding/binary"
	"math/bits"
)

func additionalData128aGeneric(s *state, ad []byte) {
	s0 := s.x0
	s1 := s.x1
	s2 := s.x2
	s3 := s.x3
	s4 := s.x4
	for len(ad) >= BlockSize128a {
		s0 ^= binary.BigEndian.Uint64(ad[0:8])
		s1 ^= binary.BigEndian.Uint64(ad[8:16])
		for C := uint64(180); C >= 74; C -= 15 {
			// Round constant
			s2 ^= C

			// Substitution
			s0 ^= s4
			s4 ^= s3
			s2 ^= s1

			// Keccak S-box
			t0 := s0 ^ (^s1 & s2)
			t1 := s1 ^ (^s2 & s3)
			t2 := s2 ^ (^s3 & s4)
			t3 := s3 ^ (^s4 & s0)
			t4 := s4 ^ (^s0 & s1)

			// Substitution
			t1 ^= t0
			t0 ^= t4
			t3 ^= t2
			t2 = ^t2

			// Linear diffusion
			//
			// x0 ← Σ0(x0) = x0 ⊕ (x0 ≫ 19) ⊕ (x0 ≫ 28)
			s0 = t0 ^ bits.RotateLeft64(t0, -19) ^ bits.RotateLeft64(t0, -28)
			// x1 ← Σ1(x1) = x1 ⊕ (x1 ≫ 61) ⊕ (x1 ≫ 39)
			s1 = t1 ^ bits.RotateLeft64(t1, -61) ^ bits.RotateLeft64(t1, -39)
			// x2 ← Σ2(x2) = x2 ⊕ (x2 ≫ 1) ⊕ (x2 ≫ 6)
			s2 = t2 ^ bits.RotateLeft64(t2, -1) ^ bits.RotateLeft64(t2, -6)
			// x3 ← Σ3(x3) = x3 ⊕ (x3 ≫ 10) ⊕ (x3 ≫ 17)
			s3 = t3 ^ bits.RotateLeft64(t3, -10) ^ bits.RotateLeft64(t3, -17)
			// x4 ← Σ4(x4) = x4 ⊕ (x4 ≫ 7) ⊕ (x4 ≫ 41)
			s4 = t4 ^ bits.RotateLeft64(t4, -7) ^ bits.RotateLeft64(t4, -41)
		}
		ad = ad[BlockSize128a:]
	}
	s.x0 = s0
	s.x1 = s1
	s.x2 = s2
	s.x3 = s3
	s.x4 = s4
}

func encryptBlocks128aGeneric(s *state, dst, src []byte) {
	s0 := s.x0
	s1 := s.x1
	s2 := s.x2
	s3 := s.x3
	s4 := s.x4
	for len(src) >= BlockSize128a && len(dst) >= BlockSize128a {
		s0 ^= binary.BigEndian.Uint64(src[0:8])
		s1 ^= binary.BigEndian.Uint64(src[8:16])
		binary.BigEndian.PutUint64(dst[0:8], s0)
		binary.BigEndian.PutUint64(dst[8:16], s1)
		for C := uint64(180); C >= 74; C -= 15 {
			// Round constant
			s2 ^= C

			// Substitution
			s0 ^= s4
			s4 ^= s3
			s2 ^= s1

			// Keccak S-box
			t0 := s0 ^ (^s1 & s2)
			t1 := s1 ^ (^s2 & s3)
			t2 := s2 ^ (^s3 & s4)
			t3 := s3 ^ (^s4 & s0)
			t4 := s4 ^ (^s0 & s1)

			// Substitution
			t1 ^= t0
			t0 ^= t4
			t3 ^= t2
			t2 = ^t2

			// Linear diffusion
			//
			// x0 ← Σ0(x0) = x0 ⊕ (x0 ≫ 19) ⊕ (x0 ≫ 28)
			s0 = t0 ^ bits.RotateLeft64(t0, -19) ^ bits.RotateLeft64(t0, -28)
			// x1 ← Σ1(x1) = x1 ⊕ (x1 ≫ 61) ⊕ (x1 ≫ 39)
			s1 = t1 ^ bits.RotateLeft64(t1, -61) ^ bits.RotateLeft64(t1, -39)
			// x2 ← Σ2(x2) = x2 ⊕ (x2 ≫ 1) ⊕ (x2 ≫ 6)
			s2 = t2 ^ bits.RotateLeft64(t2, -1) ^ bits.RotateLeft64(t2, -6)
			// x3 ← Σ3(x3) = x3 ⊕ (x3 ≫ 10) ⊕ (x3 ≫ 17)
			s3 = t3 ^ bits.RotateLeft64(t3, -10) ^ bits.RotateLeft64(t3, -17)
			// x4 ← Σ4(x4) = x4 ⊕ (x4 ≫ 7) ⊕ (x4 ≫ 41)
			s4 = t4 ^ bits.RotateLeft64(t4, -7) ^ bits.RotateLeft64(t4, -41)
		}
		src = src[BlockSize128a:]
		dst = dst[BlockSize128a:]
	}
	s.x0 = s0
	s.x1 = s1
	s.x2 = s2
	s.x3 = s3
	s.x4 = s4
}

func decryptBlocks128aGeneric(s *state, dst, src []byte) {
	s0 := s.x0
	s1 := s.x1
	s2 := s.x2
	s3 := s.x3
	s4 := s.x4
	for len(src) >= BlockSize128a && len(dst) >= BlockSize128a {
		c0 := binary.BigEndian.Uint64(src[0:8])
		c1 := binary.BigEndian.Uint64(src[8:16])
		binary.BigEndian.PutUint64(dst[0:8], s0^c0)
		binary.BigEndian.PutUint64(dst[8:16], s1^c1)
		s0, s1 = c0, c1
		for C := uint64(180); C >= 74; C -= 15 {
			// Round constant
			s2 ^= C

			// Substitution
			s0 ^= s4
			s4 ^= s3
			s2 ^= s1

			// Keccak S-box
			t0 := s0 ^ (^s1 & s2)
			t1 := s1 ^ (^s2 & s3)
			t2 := s2 ^ (^s3 & s4)
			t3 := s3 ^ (^s4 & s0)
			t4 := s4 ^ (^s0 & s1)

			// Substitution
			t1 ^= t0
			t0 ^= t4
			t3 ^= t2
			t2 = ^t2

			// Linear diffusion
			//
			// x0 ← Σ0(x0) = x0 ⊕ (x0 ≫ 19) ⊕ (x0 ≫ 28)
			s0 = t0 ^ bits.RotateLeft64(t0, -19) ^ bits.RotateLeft64(t0, -28)
			// x1 ← Σ1(x1) = x1 ⊕ (x1 ≫ 61) ⊕ (x1 ≫ 39)
			s1 = t1 ^ bits.RotateLeft64(t1, -61) ^ bits.RotateLeft64(t1, -39)
			// x2 ← Σ2(x2) = x2 ⊕ (x2 ≫ 1) ⊕ (x2 ≫ 6)
			s2 = t2 ^ bits.RotateLeft64(t2, -1) ^ bits.RotateLeft64(t2, -6)
			// x3 ← Σ3(x3) = x3 ⊕ (x3 ≫ 10) ⊕ (x3 ≫ 17)
			s3 = t3 ^ bits.RotateLeft64(t3, -10) ^ bits.RotateLeft64(t3, -17)
			// x4 ← Σ4(x4) = x4 ⊕ (x4 ≫ 7) ⊕ (x4 ≫ 41)
			s4 = t4 ^ bits.RotateLeft64(t4, -7) ^ bits.RotateLeft64(t4, -41)
		}
		src = src[BlockSize128a:]
		dst = dst[BlockSize128a:]
	}
	s.x0 = s0
	s.x1 = s1
	s.x2 = s2
	s.x3 = s3
	s.x4 = s4
}

func roundGeneric(s *state, C uint64) {
	s0 := s.x0
	s1 := s.x1
	s2 := s.x2
	s3 := s.x3
	s4 := s.x4
	// Round constant
	s2 ^= C

	// Substitution
	s0 ^= s4
	s4 ^= s3
	s2 ^= s1

	// Keccak S-box
	t0 := s0 ^ (^s1 & s2)
	t1 := s1 ^ (^s2 & s3)
	t2 := s2 ^ (^s3 & s4)
	t3 := s3 ^ (^s4 & s0)
	t4 := s4 ^ (^s0 & s1)

	// Substitution
	t1 ^= t0
	t0 ^= t4
	t3 ^= t2
	t2 = ^t2

	// Linear diffusion
	//
	// x0 ← Σ0(x0) = x0 ⊕ (x0 ≫ 19) ⊕ (x0 ≫ 28)
	s0 = t0 ^ bits.RotateLeft64(t0, -19) ^ bits.RotateLeft64(t0, -28)
	// x1 ← Σ1(x1) = x1 ⊕ (x1 ≫ 61) ⊕ (x1 ≫ 39)
	s1 = t1 ^ bits.RotateLeft64(t1, -61) ^ bits.RotateLeft64(t1, -39)
	// x2 ← Σ2(x2) = x2 ⊕ (x2 ≫ 1) ⊕ (x2 ≫ 6)
	s2 = t2 ^ bits.RotateLeft64(t2, -1) ^ bits.RotateLeft64(t2, -6)
	// x3 ← Σ3(x3) = x3 ⊕ (x3 ≫ 10) ⊕ (x3 ≫ 17)
	s3 = t3 ^ bits.RotateLeft64(t3, -10) ^ bits.RotateLeft64(t3, -17)
	// x4 ← Σ4(x4) = x4 ⊕ (x4 ≫ 7) ⊕ (x4 ≫ 41)
	s4 = t4 ^ bits.RotateLeft64(t4, -7) ^ bits.RotateLeft64(t4, -41)
	s.x0 = s0
	s.x1 = s1
	s.x2 = s2
	s.x3 = s3
	s.x4 = s4
}

func p6Generic(s *state) {
	s0 := s.x0
	s1 := s.x1
	s2 := s.x2
	s3 := s.x3
	s4 := s.x4
	for C := uint64(150); C >= 74; C -= 15 {
		// Round constant
		s2 ^= C

		// Substitution
		s0 ^= s4
		s4 ^= s3
		s2 ^= s1

		// Keccak S-box
		t0 := s0 ^ (^s1 & s2)
		t1 := s1 ^ (^s2 & s3)
		t2 := s2 ^ (^s3 & s4)
		t3 := s3 ^ (^s4 & s0)
		t4 := s4 ^ (^s0 & s1)

		// Substitution
		t1 ^= t0
		t0 ^= t4
		t3 ^= t2
		t2 = ^t2

		// Linear diffusion
		//
		// x0 ← Σ0(x0) = x0 ⊕ (x0 ≫ 19) ⊕ (x0 ≫ 28)
		s0 = t0 ^ bits.RotateLeft64(t0, -19) ^ bits.RotateLeft64(t0, -28)
		// x1 ← Σ1(x1) = x1 ⊕ (x1 ≫ 61) ⊕ (x1 ≫ 39)
		s1 = t1 ^ bits.RotateLeft64(t1, -61) ^ bits.RotateLeft64(t1, -39)
		// x2 ← Σ2(x2) = x2 ⊕ (x2 ≫ 1) ⊕ (x2 ≫ 6)
		s2 = t2 ^ bits.RotateLeft64(t2, -1) ^ bits.RotateLeft64(t2, -6)
		// x3 ← Σ3(x3) = x3 ⊕ (x3 ≫ 10) ⊕ (x3 ≫ 17)
		s3 = t3 ^ bits.RotateLeft64(t3, -10) ^ bits.RotateLeft64(t3, -17)
		// x4 ← Σ4(x4) = x4 ⊕ (x4 ≫ 7) ⊕ (x4 ≫ 41)
		s4 = t4 ^ bits.RotateLeft64(t4, -7) ^ bits.RotateLeft64(t4, -41)
	}
	s.x0 = s0
	s.x1 = s1
	s.x2 = s2
	s.x3 = s3
	s.x4 = s4
}

func p8Generic(s *state) {
	s0 := s.x0
	s1 := s.x1
	s2 := s.x2
	s3 := s.x3
	s4 := s.x4
	for C := uint64(180); C >= 74; C -= 15 {
		// Round constant
		s2 ^= C

		// Substitution
		s0 ^= s4
		s4 ^= s3
		s2 ^= s1

		// Keccak S-box
		t0 := s0 ^ (^s1 & s2)
		t1 := s1 ^ (^s2 & s3)
		t2 := s2 ^ (^s3 & s4)
		t3 := s3 ^ (^s4 & s0)
		t4 := s4 ^ (^s0 & s1)

		// Substitution
		t1 ^= t0
		t0 ^= t4
		t3 ^= t2
		t2 = ^t2

		// Linear diffusion
		//
		// x0 ← Σ0(x0) = x0 ⊕ (x0 ≫ 19) ⊕ (x0 ≫ 28)
		s0 = t0 ^ bits.RotateLeft64(t0, -19) ^ bits.RotateLeft64(t0, -28)
		// x1 ← Σ1(x1) = x1 ⊕ (x1 ≫ 61) ⊕ (x1 ≫ 39)
		s1 = t1 ^ bits.RotateLeft64(t1, -61) ^ bits.RotateLeft64(t1, -39)
		// x2 ← Σ2(x2) = x2 ⊕ (x2 ≫ 1) ⊕ (x2 ≫ 6)
		s2 = t2 ^ bits.RotateLeft64(t2, -1) ^ bits.RotateLeft64(t2, -6)
		// x3 ← Σ3(x3) = x3 ⊕ (x3 ≫ 10) ⊕ (x3 ≫ 17)
		s3 = t3 ^ bits.RotateLeft64(t3, -10) ^ bits.RotateLeft64(t3, -17)
		// x4 ← Σ4(x4) = x4 ⊕ (x4 ≫ 7) ⊕ (x4 ≫ 41)
		s4 = t4 ^ bits.RotateLeft64(t4, -7) ^ bits.RotateLeft64(t4, -41)
	}
	s.x0 = s0
	s.x1 = s1
	s.x2 = s2
	s.x3 = s3
	s.x4 = s4
}

func p12Generic(s *state) {
	s0 := s.x0
	s1 := s.x1
	s2 := s.x2
	s3 := s.x3
	s4 := s.x4
	for C := uint64(240); C >= 74; C -= 15 {
		// Round constant
		s2 ^= C

		// Substitution
		s0 ^= s4
		s4 ^= s3
		s2 ^= s1

		// Keccak S-box
		t0 := s0 ^ (^s1 & s2)
		t1 := s1 ^ (^s2 & s3)
		t2 := s2 ^ (^s3 & s4)
		t3 := s3 ^ (^s4 & s0)
		t4 := s4 ^ (^s0 & s1)

		// Substitution
		t1 ^= t0
		t0 ^= t4
		t3 ^= t2
		t2 = ^t2

		// Linear diffusion
		//
		// x0 ← Σ0(x0) = x0 ⊕ (x0 ≫ 19) ⊕ (x0 ≫ 28)
		s0 = t0 ^ bits.RotateLeft64(t0, -19) ^ bits.RotateLeft64(t0, -28)
		// x1 ← Σ1(x1) = x1 ⊕ (x1 ≫ 61) ⊕ (x1 ≫ 39)
		s1 = t1 ^ bits.RotateLeft64(t1, -61) ^ bits.RotateLeft64(t1, -39)
		// x2 ← Σ2(x2) = x2 ⊕ (x2 ≫ 1) ⊕ (x2 ≫ 6)
		s2 = t2 ^ bits.RotateLeft64(t2, -1) ^ bits.RotateLeft64(t2, -6)
		// x3 ← Σ3(x3) = x3 ⊕ (x3 ≫ 10) ⊕ (x3 ≫ 17)
		s3 = t3 ^ bits.RotateLeft64(t3, -10) ^ bits.RotateLeft64(t3, -17)
		// x4 ← Σ4(x4) = x4 ⊕ (x4 ≫ 7) ⊕ (x4 ≫ 41)
		s4 = t4 ^ bits.RotateLeft64(t4, -7) ^ bits.RotateLeft64(t4, -41)
	}
	s.x0 = s0
	s.x1 = s1
	s.x2 = s2
	s.x3 = s3
	s.x4 = s4
}
