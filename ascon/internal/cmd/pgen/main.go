package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
)

func main() {
	if err := main1(); err != nil {
		panic(err)
	}
}

func main1() error {
	var b bytes.Buffer
	b.WriteString("// Code generated by pgen.go. DO NOT EDIT.\n\n")
	b.WriteString("package ascon\n")
	b.WriteString(`import (
	"encoding/binary"
	"math/bits"
)
`)

	genAD(&b)
	genEncrypt(&b)
	genDecrypt(&b)
	genRound(&b)

	// Generate the permutations.
	for _, nr := range []int{6, 8, 12} {
		fmt.Fprintf(&b, "func p%dGeneric(s *state) {\n", nr)
		b.WriteString(load)
		pbody(&b, nr)
		b.WriteString(store)
		b.WriteString("}\n\n")
	}

	buf, err := format.Source(b.Bytes())
	if err != nil {
		fmt.Println(b.String())
		return err
	}
	return os.WriteFile("zascon_generic.go", buf, 0644)
}

func genAD(b *bytes.Buffer) {
	b.WriteString("func additionalData128aGeneric(s *state, ad []byte) {\n")
	b.WriteString(load)
	b.WriteString("for len(ad) >= BlockSize128a {\n")
	b.WriteString("s0 ^= binary.BigEndian.Uint64(ad[0:8])\n")
	b.WriteString("s1 ^= binary.BigEndian.Uint64(ad[8:16])\n")
	pbody(b, 8)
	b.WriteString("ad = ad[BlockSize128a:]\n")
	b.WriteString("}\n")
	b.WriteString(store)
	b.WriteString("}\n\n")
}

func genEncrypt(b *bytes.Buffer) {
	b.WriteString("func encryptBlocks128aGeneric(s *state, dst, src []byte) {\n")
	b.WriteString(load)
	b.WriteString("for len(src) >= BlockSize128a && len(dst) >= BlockSize128a {\n")
	b.WriteString("s0 ^= binary.BigEndian.Uint64(src[0:8])\n")
	b.WriteString("s1 ^= binary.BigEndian.Uint64(src[8:16])\n")
	b.WriteString("binary.BigEndian.PutUint64(dst[0:8], s0)\n")
	b.WriteString("binary.BigEndian.PutUint64(dst[8:16], s1)\n")
	pbody(b, 8)
	b.WriteString("src = src[BlockSize128a:]\n")
	b.WriteString("dst = dst[BlockSize128a:]\n")
	b.WriteString("}\n")
	b.WriteString(store)
	b.WriteString("}\n\n")
}

func genDecrypt(b *bytes.Buffer) {
	b.WriteString("func decryptBlocks128aGeneric(s *state, dst, src []byte) {\n")
	b.WriteString(load)
	b.WriteString("for len(src) >= BlockSize128a && len(dst) >= BlockSize128a {\n")
	b.WriteString("c0 := binary.BigEndian.Uint64(src[0:8])\n")
	b.WriteString("c1 := binary.BigEndian.Uint64(src[8:16])\n")
	b.WriteString("binary.BigEndian.PutUint64(dst[0:8], s0^c0)\n")
	b.WriteString("binary.BigEndian.PutUint64(dst[8:16], s1^c1)\n")
	b.WriteString("s0, s1 = c0, c1\n")
	pbody(b, 8)
	b.WriteString("src = src[BlockSize128a:]\n")
	b.WriteString("dst = dst[BlockSize128a:]\n")
	b.WriteString("}\n")
	b.WriteString(store)
	b.WriteString("}\n\n")
}

func genRound(b *bytes.Buffer) {
	b.WriteString("func roundGeneric(s *state, C uint64) {\n")
	b.WriteString(load)
	b.WriteString(roundBody)
	b.WriteString(store)
	b.WriteString("}\n\n")
}

// pbody generates the body of a permutation.
func pbody(b *bytes.Buffer, nr int) {
	start := ((3+nr)<<4 | (12 - nr))
	fmt.Fprintf(b, "for C := uint64(%d); C >= 74; C -= 15 {\n", start)
	b.WriteString(roundBody)
	b.WriteString("}\n")
}

const load = `s0 := s.x0
s1 := s.x1
s2 := s.x2
s3 := s.x3
s4 := s.x4
`

const store = `s.x0 = s0
s.x1 = s1
s.x2 = s2
s.x3 = s3
s.x4 = s4
`

const roundBody = `// Round constant
s2 ^= C

// Substitution
s0 ^= s4
s4 ^= s3
s2 ^= s1

// Keccak S-box
t0 := s0 ^ (^s1 & s2)
t1 := s1 ^ (^s2 & s3)
t2 := s2 ^ (^s3 & s4)
t3 := s3 ^ (^s4 & s0)
t4 := s4 ^ (^s0 & s1)

// Substitution
t1 ^= t0
t0 ^= t4
t3 ^= t2
t2 = ^t2

// Linear diffusion
//
// x0 ← Σ0(x0) = x0 ⊕ (x0 ≫ 19) ⊕ (x0 ≫ 28)
s0 = t0 ^ bits.RotateLeft64(t0, -19) ^ bits.RotateLeft64(t0, -28)
// x1 ← Σ1(x1) = x1 ⊕ (x1 ≫ 61) ⊕ (x1 ≫ 39)
s1 = t1 ^ bits.RotateLeft64(t1, -61) ^ bits.RotateLeft64(t1, -39)
// x2 ← Σ2(x2) = x2 ⊕ (x2 ≫ 1) ⊕ (x2 ≫ 6)
s2 = t2 ^ bits.RotateLeft64(t2, -1) ^ bits.RotateLeft64(t2, -6)
// x3 ← Σ3(x3) = x3 ⊕ (x3 ≫ 10) ⊕ (x3 ≫ 17)
s3 = t3 ^ bits.RotateLeft64(t3, -10) ^ bits.RotateLeft64(t3, -17)
// x4 ← Σ4(x4) = x4 ⊕ (x4 ≫ 7) ⊕ (x4 ≫ 41)
s4 = t4 ^ bits.RotateLeft64(t4, -7) ^ bits.RotateLeft64(t4, -41)
`
